<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>{{TITLE}}</title>
  <style>
    :root {
      {{THEME_VARS}}
      --body-bg: {{BODY_BG}};
      --container-bg: {{CONTAINER_BG}};
      --info-bg: {{INFO_BG}};
    }

    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      font-family: ui-monospace, 'Cascadia Code', 'Source Code Pro', Menlo, Consolas, 'DejaVu Sans Mono', monospace;
      font-size: 12px;
      line-height: 1.6;
      color: var(--text);
      background: var(--body-bg);
    }

    #app {
      display: flex;
      min-height: 100vh;
    }

    /* Sidebar */
    #sidebar {
      width: 400px;
      background: var(--container-bg);
      flex-shrink: 0;
      display: flex;
      flex-direction: column;
      position: sticky;
      top: 0;
      height: 100vh;
      border-right: 1px solid var(--dim);
    }

    .sidebar-header {
      padding: 8px 12px;
      flex-shrink: 0;
    }

    .sidebar-controls {
      display: flex;
      gap: 6px;
      align-items: center;
      flex-wrap: wrap;
    }

    .sidebar-search {
      flex: 1;
      min-width: 120px;
      padding: 4px 8px;
      font-size: 11px;
      font-family: inherit;
      background: var(--body-bg);
      color: var(--text);
      border: 1px solid var(--dim);
      border-radius: 3px;
    }

    .sidebar-search:focus {
      outline: none;
      border-color: var(--accent);
    }

    .sidebar-search::placeholder {
      color: var(--muted);
    }

    .filter-btn {
      padding: 3px 8px;
      font-size: 10px;
      font-family: inherit;
      background: transparent;
      color: var(--muted);
      border: 1px solid var(--dim);
      border-radius: 3px;
      cursor: pointer;
    }

    .filter-btn:hover {
      color: var(--text);
      border-color: var(--text);
    }

    .filter-btn.active {
      background: var(--accent);
      color: var(--body-bg);
      border-color: var(--accent);
    }

    .tree-container {
      flex: 1;
      overflow: auto;
      padding: 4px 0;
    }

    .tree-node {
      padding: 2px 8px;
      cursor: pointer;
      display: flex;
      align-items: baseline;
      font-size: 11px;
      white-space: nowrap;
    }

    .tree-node:hover {
      background: var(--selectedBg);
    }

    .tree-node.active {
      background: var(--selectedBg);
      border-left: 2px solid var(--accent);
      padding-left: 6px;
    }

    .tree-node.active .tree-content {
      font-weight: bold;
    }

    .tree-node.in-path {
      border-left: 2px solid var(--dim);
      padding-left: 6px;
    }

    .tree-prefix {
      color: var(--dim);
      flex-shrink: 0;
      font-family: inherit;
    }

    .tree-marker {
      color: var(--accent);
      flex-shrink: 0;
    }

    .tree-content {
      color: var(--text);
    }

    .tree-role-user {
      color: var(--accent);
    }

    .tree-role-assistant {
      color: var(--success);
    }

    .tree-role-tool {
      color: var(--muted);
    }

    .tree-muted {
      color: var(--muted);
    }

    .tree-error {
      color: var(--error);
    }

    .tree-compaction {
      color: var(--borderAccent);
    }

    .tree-branch-summary {
      color: var(--warning);
    }

    .tree-status {
      padding: 4px 12px;
      font-size: 10px;
      color: var(--muted);
      flex-shrink: 0;
    }

    /* Main content */
    #content {
      flex: 1;
      overflow-y: auto;
      padding: 24px 48px;
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    #content > * {
      width: 100%;
      max-width: 800px;
    }

    /* Header */
    .header {
      background: var(--container-bg);
      border-radius: 4px;
      padding: 16px;
      margin-bottom: 16px;
    }

    .header h1 {
      font-size: 14px;
      font-weight: bold;
      color: var(--borderAccent);
      margin-bottom: 12px;
    }

    .header-info {
      display: flex;
      flex-direction: column;
      gap: 3px;
      font-size: 11px;
    }

    .info-item {
      color: var(--dim);
      display: flex;
      align-items: baseline;
    }

    .info-label {
      font-weight: 600;
      margin-right: 8px;
      min-width: 100px;
    }

    .info-value {
      color: var(--text);
      flex: 1;
    }

    /* Messages */
    #messages {
      display: flex;
      flex-direction: column;
      gap: 16px;
    }

    .message-timestamp {
      font-size: 10px;
      color: var(--dim);
      margin-bottom: 4px;
      opacity: 0.8;
    }

    .user-message {
      background: var(--userMessageBg);
      color: var(--userMessageText);
      padding: 12px 16px;
      border-radius: 4px;
    }

    .assistant-message {
      padding: 0;
    }

    .assistant-text {
      padding: 12px 16px;
    }

    .thinking-text {
      padding: 12px 16px;
      color: var(--thinkingText);
      font-style: italic;
      white-space: pre-wrap;
    }

    /* Tool execution */
    .tool-execution {
      padding: 12px 16px;
      border-radius: 4px;
      margin-top: 8px;
    }

    .tool-execution.pending { background: var(--toolPendingBg); }
    .tool-execution.success { background: var(--toolSuccessBg); }
    .tool-execution.error { background: var(--toolErrorBg); }

    .tool-header, .tool-name {
      font-weight: bold;
    }

    .tool-path {
      color: var(--borderAccent);
      word-break: break-all;
    }

    .line-numbers {
      color: var(--warning);
    }

    .line-count {
      color: var(--dim);
    }

    .tool-command {
      font-weight: bold;
      white-space: pre-wrap;
      word-wrap: break-word;
      overflow-wrap: break-word;
      word-break: break-word;
    }

    .tool-output {
      margin-top: 12px;
      color: var(--toolOutput);
      white-space: pre-wrap;
      word-wrap: break-word;
      overflow-wrap: break-word;
      word-break: break-word;
      font-family: inherit;
      overflow-x: auto;
    }

    .tool-output > div {
      line-height: 1.4;
    }

    .tool-output pre {
      margin: 0;
      padding: 0;
      font-family: inherit;
      color: inherit;
      white-space: pre-wrap;
      word-wrap: break-word;
      overflow-wrap: break-word;
    }

    .tool-output code {
      padding: 0;
      background: none;
    }

    .tool-output.expandable {
      cursor: pointer;
    }

    .tool-output.expandable:hover {
      opacity: 0.9;
    }

    .tool-output.expandable .output-full {
      display: none;
    }

    .tool-output.expandable.expanded .output-preview {
      display: none;
    }

    .tool-output.expandable.expanded .output-full {
      display: block;
    }

    .expand-hint {
      color: var(--borderAccent);
      font-style: italic;
      margin-top: 4px;
    }

    /* Diff */
    .tool-diff {
      margin-top: 12px;
      font-size: 11px;
      overflow-x: auto;
    }

    .diff-added { color: var(--toolDiffAdded); }
    .diff-removed { color: var(--toolDiffRemoved); }
    .diff-context { color: var(--toolDiffContext); }

    /* Model change */
    .model-change {
      padding: 8px 16px;
      background: var(--info-bg);
      border-radius: 4px;
      color: var(--dim);
      font-size: 11px;
    }

    .model-name {
      color: var(--borderAccent);
      font-weight: bold;
    }

    /* Compaction */
    .compaction {
      background: var(--info-bg);
      border-radius: 4px;
      overflow: hidden;
    }

    .compaction-header {
      padding: 12px 16px;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .compaction-header:hover {
      background: var(--selectedBg);
    }

    .compaction-toggle {
      color: var(--borderAccent);
      font-size: 10px;
      transition: transform 0.2s;
    }

    .compaction.expanded .compaction-toggle {
      transform: rotate(90deg);
    }

    .compaction-title {
      color: var(--text);
      font-weight: bold;
    }

    .compaction-content {
      display: none;
      padding: 0 16px 16px;
    }

    .compaction.expanded .compaction-content {
      display: block;
    }

    .compaction-summary {
      background: var(--selectedBg);
      border-radius: 4px;
      padding: 12px;
      white-space: pre-wrap;
    }

    /* System prompt */
    .system-prompt {
      background: var(--info-bg);
      padding: 12px 16px;
      border-radius: 4px;
      margin-bottom: 16px;
    }

    .system-prompt-header {
      font-weight: bold;
      color: var(--warning);
      margin-bottom: 8px;
    }

    .system-prompt-content {
      color: var(--dim);
      white-space: pre-wrap;
      word-wrap: break-word;
      font-size: 11px;
      max-height: 200px;
      overflow-y: auto;
    }

    /* Tools list */
    .tools-list {
      background: var(--customMessageBg);
      padding: 12px 16px;
      border-radius: 4px;
      margin-bottom: 16px;
    }

    .tools-header {
      font-weight: bold;
      color: var(--warning);
      margin-bottom: 8px;
    }

    .tool-item {
      margin: 4px 0;
      font-size: 11px;
    }

    .tool-item-name {
      font-weight: bold;
      color: var(--text);
    }

    .tool-item-desc {
      color: var(--dim);
    }

    /* Hook/custom messages */
    .hook-message {
      background: var(--customMessageBg);
      color: var(--customMessageText);
      padding: 12px 16px;
      border-radius: 4px;
    }

    .hook-type {
      color: var(--customMessageLabel);
      font-weight: bold;
      margin-bottom: 4px;
    }

    /* Branch summary */
    .branch-summary {
      background: var(--customMessageBg);
      padding: 12px 16px;
      border-radius: 4px;
    }

    .branch-summary-header {
      font-weight: bold;
      color: var(--borderAccent);
      margin-bottom: 8px;
    }

    /* Error */
    .error-text {
      color: var(--error);
      padding: 12px 16px;
    }

    /* Images */
    .message-images {
      margin-bottom: 12px;
    }

    .message-image {
      max-width: 100%;
      max-height: 400px;
      border-radius: 4px;
      margin: 4px 0;
    }

    /* Markdown content */
    .markdown-content h1,
    .markdown-content h2,
    .markdown-content h3,
    .markdown-content h4,
    .markdown-content h5,
    .markdown-content h6 {
      color: var(--mdHeading);
      margin: 1em 0 0.5em 0;
      font-weight: bold;
    }

    .markdown-content h1 { font-size: 1em; }
    .markdown-content h2 { font-size: 1em; }
    .markdown-content h3 { font-size: 1em; }
    .markdown-content h4 { font-size: 1em; }
    .markdown-content h5 { font-size: 1em; }
    .markdown-content h6 { font-size: 1em; }
    .markdown-content p { margin: 0.5em 0; }

    .markdown-content a {
      color: var(--mdLink);
      text-decoration: underline;
    }

    .markdown-content code {
      background: rgba(128, 128, 128, 0.2);
      color: var(--mdCode);
      padding: 2px 6px;
      border-radius: 3px;
      font-family: inherit;
    }

    .markdown-content pre {
      background: transparent;
      margin: 0.5em 0;
      overflow-x: auto;
    }

    .markdown-content pre code {
      display: block;
      background: none;
      color: var(--mdCodeBlock);
      padding: 8px 12px;
    }

    .markdown-content blockquote {
      border-left: 3px solid var(--mdQuoteBorder);
      padding-left: 12px;
      margin: 0.5em 0;
      color: var(--mdQuote);
      font-style: italic;
    }

    .markdown-content ul,
    .markdown-content ol {
      margin: 0.5em 0;
      padding-left: 24px;
    }

    .markdown-content li { margin: 0.25em 0; }
    .markdown-content li::marker { color: var(--mdListBullet); }

    .markdown-content hr {
      border: none;
      border-top: 1px solid var(--mdHr);
      margin: 1em 0;
    }

    .markdown-content table {
      border-collapse: collapse;
      margin: 0.5em 0;
      width: 100%;
    }

    .markdown-content th,
    .markdown-content td {
      border: 1px solid var(--mdCodeBlockBorder);
      padding: 6px 10px;
      text-align: left;
    }

    .markdown-content th {
      background: rgba(128, 128, 128, 0.1);
      font-weight: bold;
    }

    .markdown-content img {
      max-width: 100%;
      border-radius: 4px;
    }

    /* Syntax highlighting */
    .hljs { background: transparent; }
    .hljs-comment, .hljs-quote { color: var(--syntaxComment); }
    .hljs-keyword, .hljs-selector-tag { color: var(--syntaxKeyword); }
    .hljs-number, .hljs-literal { color: var(--syntaxNumber); }
    .hljs-string, .hljs-doctag { color: var(--syntaxString); }
    .hljs-title, .hljs-section, .hljs-name { color: var(--syntaxFunction); }
    .hljs-type, .hljs-class, .hljs-built_in { color: var(--syntaxType); }
    .hljs-attr, .hljs-variable, .hljs-params { color: var(--syntaxVariable); }
    .hljs-meta { color: var(--syntaxKeyword); }

    /* Footer */
    .footer {
      margin-top: 48px;
      padding: 20px;
      text-align: center;
      color: var(--dim);
      font-size: 10px;
    }

    /* Mobile */
    #sidebar-toggle {
      display: none;
      position: fixed;
      top: 10px;
      left: 10px;
      z-index: 100;
      background: var(--accent);
      color: var(--body-bg);
      border: none;
      padding: 8px 12px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 16px;
    }

    #sidebar-overlay {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.5);
      z-index: 98;
    }

    @media (max-width: 900px) {
      #sidebar {
        position: fixed;
        left: -400px;
        width: 400px;
        top: 0;
        bottom: 0;
        height: 100vh;
        z-index: 99;
        transition: left 0.3s;
      }

      #sidebar.open {
        left: 0;
      }

      #sidebar-overlay.open {
        display: block;
      }

      #sidebar-toggle {
        display: block;
      }

      #content {
        padding: 60px 16px 24px;
      }

      #content > * {
        max-width: 100%;
      }
    }

    @media (max-width: 500px) {
      #sidebar {
        width: 100vw;
        left: -100vw;
      }
    }

    @media print {
      #sidebar, #sidebar-toggle { display: none !important; }
      body { background: white; color: black; }
      #content { max-width: none; }
    }
  </style>
</head>
<body>
  <script id="session-data" type="application/json">{{SESSION_DATA}}</script>

  <button id="sidebar-toggle">☰</button>
  <div id="sidebar-overlay"></div>

  <div id="app">
    <aside id="sidebar">
      <div class="sidebar-header">
        <div class="sidebar-controls">
          <input type="text" class="sidebar-search" id="tree-search" placeholder="Search...">
          <button class="filter-btn active" data-filter="default" title="Hide settings entries">Default</button>
          <button class="filter-btn" data-filter="all" title="Show everything">All</button>
          <button class="filter-btn" data-filter="labeled" title="Only labeled entries">Labels</button>
        </div>
      </div>
      <div class="tree-container" id="tree-container"></div>
      <div class="tree-status" id="tree-status"></div>
    </aside>
    <main id="content">
      <div id="header-container"></div>
      <div id="messages"></div>
      <div class="footer">
        Generated by {{APP_NAME}} on {{GENERATED_DATE}}
      </div>
    </main>
  </div>

  <!-- Vendored: marked.js -->
  <script>{{MARKED_JS}}</script>

  <!-- Vendored: highlight.js -->
  <script>{{HIGHLIGHT_JS}}</script>

  <!-- Session renderer -->
  <script>
    (function() {
      'use strict';

      const data = JSON.parse(atob(document.getElementById('session-data').textContent));
      const { header, entries, leafId, systemPrompt, tools } = data;

      // Build entry index
      const byId = new Map();
      for (const entry of entries) {
        byId.set(entry.id, entry);
      }

      // Build tree structure
      // Build tree structure from entries
      function buildTree() {
        const nodeMap = new Map();
        const roots = [];

        for (const entry of entries) {
          nodeMap.set(entry.id, { entry, children: [] });
        }

        for (const entry of entries) {
          const node = nodeMap.get(entry.id);
          if (!entry.parentId) {
            roots.push(node);
          } else {
            const parent = nodeMap.get(entry.parentId);
            if (parent) {
              parent.children.push(node);
            } else {
              roots.push(node);
            }
          }
        }

        // Sort children by timestamp
        function sortChildren(node) {
          node.children.sort((a, b) =>
            new Date(a.entry.timestamp).getTime() - new Date(b.entry.timestamp).getTime()
          );
          node.children.forEach(sortChildren);
        }
        roots.forEach(sortChildren);

        return roots;
      }

      // Get path from root to target (returns set of IDs)
      function buildActivePathIds(targetId) {
        const ids = new Set();
        let current = byId.get(targetId);
        while (current) {
          ids.add(current.id);
          current = current.parentId ? byId.get(current.parentId) : null;
        }
        return ids;
      }

      // Get path from root to target (returns array of entries)
      function getPath(targetId) {
        const path = [];
        let current = byId.get(targetId);
        while (current) {
          path.unshift(current);
          current = current.parentId ? byId.get(current.parentId) : null;
        }
        return path;
      }

      // Check if content has actual text (not just tool calls)
      function hasTextContent(content) {
        if (typeof content === 'string') return content.trim().length > 0;
        if (Array.isArray(content)) {
          for (const c of content) {
            if (c.type === 'text' && c.text && c.text.trim().length > 0) return true;
          }
        }
        return false;
      }

      // Should show entry in tree (filter like tree-selector.ts)
      function shouldShowEntry(entry, isCurrentLeaf) {
        if (isCurrentLeaf) return true;

        // Hide settings/bookkeeping entries
        if (['label', 'custom', 'model_change', 'thinking_level_change'].includes(entry.type)) {
          return false;
        }

        // Hide tool results
        if (entry.type === 'message' && entry.message.role === 'toolResult') {
          return false;
        }

        // Hide assistant messages with only tool calls (no text)
        if (entry.type === 'message' && entry.message.role === 'assistant') {
          const msg = entry.message;
          const hasText = hasTextContent(msg.content);
          const isError = msg.stopReason && msg.stopReason !== 'stop' && msg.stopReason !== 'toolUse';
          if (!hasText && !isError) return false;
        }

        return true;
      }

      // Extract text content from message
      function extractContent(content) {
        if (typeof content === 'string') return content;
        if (Array.isArray(content)) {
          let result = '';
          for (const c of content) {
            if (c.type === 'text' && c.text) result += c.text;
          }
          return result;
        }
        return '';
      }

      // Get entry display text (matches tree-selector.ts)
      function getEntryDisplayText(entry) {
        const normalize = s => s.replace(/[\n\t]/g, ' ').trim();

        switch (entry.type) {
          case 'message': {
            const msg = entry.message;
            if (msg.role === 'user') {
              const content = normalize(extractContent(msg.content)).slice(0, 60);
              return `<span class="tree-role-user">user:</span> ${escapeHtml(content)}`;
            }
            if (msg.role === 'assistant') {
              const textContent = normalize(extractContent(msg.content)).slice(0, 60);
              if (textContent) {
                return `<span class="tree-role-assistant">assistant:</span> ${escapeHtml(textContent)}`;
              }
              if (msg.stopReason === 'aborted') {
                return `<span class="tree-role-assistant">assistant:</span> <span class="tree-muted">(aborted)</span>`;
              }
              if (msg.errorMessage) {
                return `<span class="tree-role-assistant">assistant:</span> <span class="tree-error">${escapeHtml(msg.errorMessage.slice(0, 50))}</span>`;
              }
              return `<span class="tree-role-assistant">assistant:</span> <span class="tree-muted">(no text)</span>`;
            }
            if (msg.role === 'bashExecution') {
              const cmd = normalize(msg.command || '').slice(0, 50);
              return `<span class="tree-muted">[bash]:</span> ${escapeHtml(cmd)}`;
            }
            return `<span class="tree-muted">[${msg.role}]</span>`;
          }
          case 'compaction':
            return `<span class="tree-compaction">[compaction: ${Math.round(entry.tokensBefore/1000)}k tokens]</span>`;
          case 'branch_summary':
            return `<span class="tree-branch-summary">[branch summary]</span>`;
          default:
            return `<span class="tree-muted">[${entry.type}]</span>`;
        }
      }

      // Flatten tree with proper indentation and gutter info (matches tree-selector.ts algorithm)
      function flattenTree(roots, activePathIds) {
        const result = [];
        const multipleRoots = roots.length > 1;

        // Mark which subtrees contain active leaf
        const containsActive = new Map();
        function markActive(node) {
          let has = activePathIds.has(node.entry.id);
          for (const child of node.children) {
            if (markActive(child)) has = true;
          }
          containsActive.set(node, has);
          return has;
        }
        roots.forEach(markActive);

        // Stack: [node, indent, showConnector, isLast, gutters, isVirtualRootChild]
        const stack = [];

        // Add roots (prioritize active branch)
        const orderedRoots = [...roots].sort((a, b) => Number(containsActive.get(b)) - Number(containsActive.get(a)));
        for (let i = orderedRoots.length - 1; i >= 0; i--) {
          const isLast = i === orderedRoots.length - 1;
          stack.push([orderedRoots[i], multipleRoots ? 1 : 0, multipleRoots, isLast, [], multipleRoots]);
        }

        while (stack.length > 0) {
          const [node, indent, showConnector, isLast, gutters, isVirtualRootChild] = stack.pop();

          result.push({ node, indent, showConnector, isLast, gutters, isVirtualRootChild, multipleRoots });

          const children = node.children;
          const multipleChildren = children.length > 1;

          // Order children (active branch first)
          const orderedChildren = [...children].sort((a, b) => Number(containsActive.get(b)) - Number(containsActive.get(a)));

          // Child indent: +1 if branching, else stay flat
          const childIndent = multipleChildren ? indent + 1 : indent;

          // Build gutters for children
          const connectorDisplayed = showConnector && !isVirtualRootChild;
          const displayIndent = multipleRoots ? Math.max(0, indent - 1) : indent;
          const connectorPosition = Math.max(0, displayIndent - 1);
          const childGutters = connectorDisplayed
            ? [...gutters, { position: connectorPosition, show: !isLast }]
            : gutters;

          // Add children in reverse
          for (let i = orderedChildren.length - 1; i >= 0; i--) {
            const childIsLast = i === orderedChildren.length - 1;
            stack.push([orderedChildren[i], childIndent, multipleChildren, childIsLast, childGutters, false]);
          }
        }

        return result;
      }

      // Build prefix string with ASCII tree chars
      function buildTreePrefix(flatNode) {
        const { indent, showConnector, isLast, gutters, isVirtualRootChild, multipleRoots } = flatNode;
        const displayIndent = multipleRoots ? Math.max(0, indent - 1) : indent;
        const connector = showConnector && !isVirtualRootChild ? (isLast ? '└─ ' : '├─ ') : '';
        const connectorPosition = connector ? displayIndent - 1 : -1;

        const totalChars = displayIndent * 3;
        const prefixChars = [];
        for (let i = 0; i < totalChars; i++) {
          const level = Math.floor(i / 3);
          const posInLevel = i % 3;

          const gutter = gutters.find(g => g.position === level);
          if (gutter) {
            if (posInLevel === 0) {
              prefixChars.push(gutter.show ? '│' : ' ');
            } else {
              prefixChars.push(' ');
            }
          } else if (connector && level === connectorPosition) {
            if (posInLevel === 0) {
              prefixChars.push(isLast ? '└' : '├');
            } else if (posInLevel === 1) {
              prefixChars.push('─');
            } else {
              prefixChars.push(' ');
            }
          } else {
            prefixChars.push(' ');
          }
        }
        return prefixChars.join('');
      }

      // Current state
      let currentPath = [];
      let activePathIds = new Set();
      let filterMode = 'default'; // 'default', 'all', 'labeled'
      let searchQuery = '';

      // Build tool call map for looking up tool info
      const toolCallMap = new Map();
      for (const entry of entries) {
        if (entry.type === 'message' && entry.message.role === 'assistant') {
          const content = entry.message.content;
          if (Array.isArray(content)) {
            for (const block of content) {
              if (block.type === 'toolCall') {
                toolCallMap.set(block.id, { name: block.name, arguments: block.arguments });
              }
            }
          }
        }
      }

      // Format tool call for display
      function formatToolCall(name, args) {
        switch (name) {
          case 'bash':
            return `[bash]: ${(args.command || '').slice(0, 40)}`;
          case 'read':
            const readPath = args.file_path || args.path || '';
            return `[read]: ${readPath.split('/').pop()}`;
          case 'write':
            const writePath = args.file_path || args.path || '';
            return `[write]: ${writePath.split('/').pop()}`;
          case 'edit':
            const editPath = args.file_path || args.path || '';
            return `[edit]: ${editPath.split('/').pop()}`;
          default:
            return `[${name}]`;
        }
      }

      // Get searchable text from entry
      function getSearchableText(entry, label) {
        const parts = [];
        if (label) parts.push(label);
        
        if (entry.type === 'message') {
          const msg = entry.message;
          parts.push(msg.role);
          if (msg.content) parts.push(extractContent(msg.content));
          if (msg.command) parts.push(msg.command);
        }
        return parts.join(' ').toLowerCase();
      }

      // Filter entry based on mode and search
      function shouldShowEntryFiltered(entry, isCurrentLeaf, label) {
        // Always show current leaf
        if (isCurrentLeaf) return true;

        // Apply filter mode
        const isSettingsEntry = ['label', 'custom', 'model_change', 'thinking_level_change'].includes(entry.type);
        
        if (filterMode === 'labeled') {
          if (!label) return false;
        } else if (filterMode === 'default') {
          // Hide settings entries
          if (isSettingsEntry) return false;
          // Hide tool results (shown via tool call lookup)
          if (entry.type === 'message' && entry.message.role === 'toolResult') return false;
          // Hide assistant messages with only tool calls (no text), unless error
          if (entry.type === 'message' && entry.message.role === 'assistant') {
            const msg = entry.message;
            const hasText = hasTextContent(msg.content);
            const isError = msg.stopReason && msg.stopReason !== 'stop' && msg.stopReason !== 'toolUse';
            if (!hasText && !isError) return false;
          }
        }
        // 'all' shows everything

        // Apply search
        if (searchQuery) {
          const text = getSearchableText(entry, label);
          const tokens = searchQuery.toLowerCase().split(/\s+/).filter(Boolean);
          if (!tokens.every(t => text.includes(t))) return false;
        }

        return true;
      }

      // Get entry display text with tool info
      function getEntryDisplayTextFull(entry, label) {
        const normalize = s => s.replace(/[\n\t]/g, ' ').trim();

        // Label prefix
        const labelHtml = label ? `<span class="tree-branch-summary">[${escapeHtml(label)}]</span> ` : '';

        switch (entry.type) {
          case 'message': {
            const msg = entry.message;
            if (msg.role === 'user') {
              const content = normalize(extractContent(msg.content)).slice(0, 60);
              return labelHtml + `<span class="tree-role-user">user:</span> ${escapeHtml(content)}`;
            }
            if (msg.role === 'assistant') {
              const textContent = normalize(extractContent(msg.content)).slice(0, 60);
              if (textContent) {
                return labelHtml + `<span class="tree-role-assistant">assistant:</span> ${escapeHtml(textContent)}`;
              }
              if (msg.stopReason === 'aborted') {
                return labelHtml + `<span class="tree-role-assistant">assistant:</span> <span class="tree-muted">(aborted)</span>`;
              }
              if (msg.errorMessage) {
                return labelHtml + `<span class="tree-role-assistant">assistant:</span> <span class="tree-error">${escapeHtml(msg.errorMessage.slice(0, 50))}</span>`;
              }
              return labelHtml + `<span class="tree-role-assistant">assistant:</span> <span class="tree-muted">(no text)</span>`;
            }
            if (msg.role === 'toolResult') {
              const toolCall = msg.toolCallId ? toolCallMap.get(msg.toolCallId) : null;
              if (toolCall) {
                return labelHtml + `<span class="tree-role-tool">${escapeHtml(formatToolCall(toolCall.name, toolCall.arguments))}</span>`;
              }
              return labelHtml + `<span class="tree-role-tool">[${msg.toolName || 'tool'}]</span>`;
            }
            if (msg.role === 'bashExecution') {
              const cmd = normalize(msg.command || '').slice(0, 50);
              return labelHtml + `<span class="tree-role-tool">[bash]:</span> ${escapeHtml(cmd)}`;
            }
            return labelHtml + `<span class="tree-muted">[${msg.role}]</span>`;
          }
          case 'compaction':
            return labelHtml + `<span class="tree-compaction">[compaction: ${Math.round(entry.tokensBefore/1000)}k tokens]</span>`;
          case 'branch_summary':
            return labelHtml + `<span class="tree-branch-summary">[branch summary]</span>`;
          case 'model_change':
            return labelHtml + `<span class="tree-muted">[model: ${entry.modelId}]</span>`;
          case 'thinking_level_change':
            return labelHtml + `<span class="tree-muted">[thinking: ${entry.thinkingLevel}]</span>`;
          default:
            return labelHtml + `<span class="tree-muted">[${entry.type}]</span>`;
        }
      }

      // Render tree sidebar
      function renderTree() {
        const tree = buildTree();
        const currentLeafId = currentPath[currentPath.length - 1]?.id || leafId;
        activePathIds = buildActivePathIds(currentLeafId);
        const flatNodes = flattenTree(tree, activePathIds);

        // Filter entries
        const filtered = flatNodes.filter(fn => 
          shouldShowEntryFiltered(fn.node.entry, fn.node.entry.id === currentLeafId, fn.node.label)
        );

        const container = document.getElementById('tree-container');
        container.innerHTML = '';

        for (const flatNode of filtered) {
          const entry = flatNode.node.entry;
          const isOnPath = activePathIds.has(entry.id);
          const isLeaf = entry.id === currentLeafId;

          const div = document.createElement('div');
          div.className = 'tree-node';
          if (isOnPath) div.classList.add('in-path');
          if (isLeaf) div.classList.add('active');
          div.dataset.id = entry.id;

          // Prefix (tree lines)
          const prefix = buildTreePrefix(flatNode);
          const prefixSpan = document.createElement('span');
          prefixSpan.className = 'tree-prefix';
          prefixSpan.textContent = prefix;

          // Path marker
          const marker = document.createElement('span');
          marker.className = 'tree-marker';
          marker.textContent = isOnPath ? '• ' : '  ';

          // Content
          const content = document.createElement('span');
          content.className = 'tree-content';
          content.innerHTML = getEntryDisplayTextFull(entry, flatNode.node.label);

          div.appendChild(prefixSpan);
          div.appendChild(marker);
          div.appendChild(content);
          div.addEventListener('click', () => navigateTo(entry.id));

          container.appendChild(div);
        }

        // Update status
        document.getElementById('tree-status').textContent = `${filtered.length} / ${flatNodes.length} entries`;
      }

      // Get text content from message content
      function getTextContent(content) {
        if (typeof content === 'string') return content;
        return content
          .filter(c => c.type === 'text')
          .map(c => c.text)
          .join('\n');
      }

      // Escape HTML
      function escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
      }

      // Configure marked
      marked.setOptions({
        breaks: true,
        gfm: true,
        highlight: function(code, lang) {
          if (lang && hljs.getLanguage(lang)) {
            try {
              return hljs.highlight(code, { language: lang }).value;
            } catch {}
          }
          return escapeHtml(code);
        }
      });

      // Render markdown
      function renderMarkdown(text) {
        return marked.parse(text);
      }

      // Format timestamp
      function formatTimestamp(ts) {
        if (!ts) return '';
        const date = new Date(ts);
        return date.toLocaleTimeString(undefined, { hour: '2-digit', minute: '2-digit', second: '2-digit' });
      }

      // Shorten path
      function shortenPath(path) {
        // Simple home dir shortening (won't work perfectly in browser but good enough)
        return path.replace(/^\/Users\/[^/]+/, '~').replace(/^\/home\/[^/]+/, '~');
      }

      // Find tool result for a tool call
      function findToolResult(toolCallId) {
        for (const entry of entries) {
          if (entry.type === 'message' && entry.message.role === 'toolResult') {
            if (entry.message.toolCallId === toolCallId) {
              return entry.message;
            }
          }
        }
        return null;
      }

      // Get language from file path
      function getLanguageFromPath(filePath) {
        const ext = filePath.split('.').pop()?.toLowerCase();
        const extToLang = {
          ts: 'typescript', tsx: 'typescript', js: 'javascript', jsx: 'javascript',
          py: 'python', rb: 'ruby', rs: 'rust', go: 'go', java: 'java',
          c: 'c', cpp: 'cpp', h: 'c', hpp: 'cpp', cs: 'csharp',
          php: 'php', sh: 'bash', bash: 'bash', zsh: 'bash',
          sql: 'sql', html: 'html', css: 'css', scss: 'scss',
          json: 'json', yaml: 'yaml', yml: 'yaml', xml: 'xml',
          md: 'markdown', dockerfile: 'dockerfile'
        };
        return extToLang[ext];
      }

      // Replace tabs with spaces
      function replaceTabs(text) {
        return text.replace(/\t/g, '   ');
      }

      // Format expandable output (matches old export-html.ts exactly)
      function formatExpandableOutput(text, maxLines, lang) {
        const lines = text.split('\n');
        const displayLines = lines.slice(0, maxLines);
        const remaining = lines.length - maxLines;

        // If language is provided, highlight the entire code block
        if (lang) {
          let highlighted;
          try {
            highlighted = hljs.highlight(text, { language: lang }).value;
          } catch {
            highlighted = escapeHtml(text);
          }

          if (remaining > 0) {
            // For expandable, we need preview and full versions
            const previewCode = displayLines.join('\n');
            let previewHighlighted;
            try {
              previewHighlighted = hljs.highlight(previewCode, { language: lang }).value;
            } catch {
              previewHighlighted = escapeHtml(previewCode);
            }

            let out = '<div class="tool-output expandable" onclick="this.classList.toggle(\'expanded\')">';
            out += `<div class="output-preview"><pre><code class="hljs">${previewHighlighted}</code></pre>`;
            out += `<div class="expand-hint">... (${remaining} more lines) - click to expand</div>`;
            out += '</div>';
            out += `<div class="output-full"><pre><code class="hljs">${highlighted}</code></pre></div></div>`;
            return out;
          }

          return `<div class="tool-output"><pre><code class="hljs">${highlighted}</code></pre></div>`;
        }

        // No language - plain text output with line-by-line divs
        if (remaining > 0) {
          let out = '<div class="tool-output expandable" onclick="this.classList.toggle(\'expanded\')">';
          out += '<div class="output-preview">';
          for (const line of displayLines) {
            out += `<div>${escapeHtml(replaceTabs(line))}</div>`;
          }
          out += `<div class="expand-hint">... (${remaining} more lines) - click to expand</div>`;
          out += '</div>';
          out += '<div class="output-full">';
          for (const line of lines) {
            out += `<div>${escapeHtml(replaceTabs(line))}</div>`;
          }
          out += '</div></div>';
          return out;
        }

        let out = '<div class="tool-output">';
        for (const line of displayLines) {
          out += `<div>${escapeHtml(replaceTabs(line))}</div>`;
        }
        out += '</div>';
        return out;
      }

      // Render tool call
      function renderToolCall(call) {
        const result = findToolResult(call.id);
        const isError = result?.isError || false;
        const statusClass = result ? (isError ? 'error' : 'success') : 'pending';

        const getResultText = () => {
          if (!result) return '';
          const textBlocks = result.content.filter(c => c.type === 'text');
          return textBlocks.map(c => c.text).join('\n');
        };

        let html = `<div class="tool-execution ${statusClass}">`;

        const args = call.arguments || {};
        const name = call.name;

        switch (name) {
          case 'bash': {
            const command = args.command || '';
            html += `<div class="tool-command">$ ${escapeHtml(command)}</div>`;
            if (result) {
              const output = getResultText().trim();
              if (output) {
                html += formatExpandableOutput(output, 5);
              }
            }
            break;
          }

          case 'read': {
            const filePath = args.file_path || args.path || '';
            const offset = args.offset;
            const limit = args.limit;
            const lang = getLanguageFromPath(filePath);

            let pathHtml = escapeHtml(shortenPath(filePath));
            if (offset !== undefined || limit !== undefined) {
              const startLine = offset ?? 1;
              const endLine = limit !== undefined ? startLine + limit - 1 : '';
              pathHtml += `<span class="line-numbers">:${startLine}${endLine ? '-' + endLine : ''}</span>`;
            }

            html += `<div class="tool-header"><span class="tool-name">read</span> <span class="tool-path">${pathHtml}</span></div>`;
            if (result) {
              const output = getResultText();
              if (output) {
                html += formatExpandableOutput(output, 10, lang);
              }
            }
            break;
          }

          case 'write': {
            const filePath = args.file_path || args.path || '';
            const content = args.content || '';
            const lines = content.split('\n');
            const lang = getLanguageFromPath(filePath);

            html += `<div class="tool-header"><span class="tool-name">write</span> <span class="tool-path">${escapeHtml(shortenPath(filePath))}</span>`;
            if (lines.length > 10) {
              html += ` <span class="line-count">(${lines.length} lines)</span>`;
            }
            html += '</div>';

            if (content) {
              html += formatExpandableOutput(content, 10, lang);
            }
            if (result) {
              const output = getResultText().trim();
              if (output) {
                html += `<div class="tool-output"><div>${escapeHtml(output)}</div></div>`;
              }
            }
            break;
          }

          case 'edit': {
            const filePath = args.file_path || args.path || '';
            html += `<div class="tool-header"><span class="tool-name">edit</span> <span class="tool-path">${escapeHtml(shortenPath(filePath))}</span></div>`;

            if (result?.details?.diff) {
              const diffLines = result.details.diff.split('\n');
              html += '<div class="tool-diff">';
              for (const line of diffLines) {
                if (line.startsWith('+')) {
                  html += `<div class="diff-added">${escapeHtml(line)}</div>`;
                } else if (line.startsWith('-')) {
                  html += `<div class="diff-removed">${escapeHtml(line)}</div>`;
                } else {
                  html += `<div class="diff-context">${escapeHtml(line)}</div>`;
                }
              }
              html += '</div>';
            }
            if (result) {
              const output = getResultText().trim();
              if (output && !result.details?.diff) {
                html += `<div class="tool-output"><pre>${escapeHtml(output)}</pre></div>`;
              }
            }
            break;
          }

          default: {
            html += `<div class="tool-header"><span class="tool-name">${escapeHtml(name)}</span></div>`;
            html += `<div class="tool-output"><pre>${escapeHtml(JSON.stringify(args, null, 2))}</pre></div>`;
            if (result) {
              const output = getResultText();
              if (output) {
                html += formatExpandableOutput(output, 10);
              }
            }
          }
        }

        html += '</div>';
        return html;
      }

      // Render a single entry
      function renderEntry(entry) {
        const ts = formatTimestamp(entry.timestamp);
        const tsHtml = ts ? `<div class="message-timestamp">${ts}</div>` : '';
        const entryId = `entry-${entry.id}`;

        if (entry.type === 'message') {
          const msg = entry.message;

          if (msg.role === 'user') {
            let html = `<div class="user-message" id="${entryId}">${tsHtml}`;
            const content = msg.content;

            // Images
            if (Array.isArray(content)) {
              const images = content.filter(c => c.type === 'image');
              if (images.length > 0) {
                html += '<div class="message-images">';
                for (const img of images) {
                  html += `<img src="data:${img.mimeType};base64,${img.data}" class="message-image" />`;
                }
                html += '</div>';
              }
            }

            // Text
            const text = getTextContent(content);
            if (text.trim()) {
              html += `<div class="markdown-content">${renderMarkdown(text)}</div>`;
            }
            html += '</div>';
            return html;
          }

          if (msg.role === 'assistant') {
            let html = `<div class="assistant-message" id="${entryId}">${tsHtml}`;

            // Text and thinking blocks
            for (const block of msg.content) {
              if (block.type === 'text' && block.text.trim()) {
                html += `<div class="assistant-text markdown-content">${renderMarkdown(block.text)}</div>`;
              } else if (block.type === 'thinking' && block.thinking.trim()) {
                html += `<div class="thinking-text">${escapeHtml(block.thinking)}</div>`;
              }
            }

            // Tool calls
            for (const block of msg.content) {
              if (block.type === 'toolCall') {
                html += renderToolCall(block);
              }
            }

            // Errors
            if (msg.stopReason === 'aborted') {
              html += '<div class="error-text">Aborted</div>';
            } else if (msg.stopReason === 'error') {
              html += `<div class="error-text">Error: ${escapeHtml(msg.errorMessage || 'Unknown error')}</div>`;
            }

            html += '</div>';
            return html;
          }

          if (msg.role === 'bashExecution') {
            const isError = msg.cancelled || (msg.exitCode !== 0 && msg.exitCode !== null);
            let html = `<div class="tool-execution ${isError ? 'error' : 'success'}" id="${entryId}">${tsHtml}`;
            html += `<div class="tool-command">$ ${escapeHtml(msg.command)}</div>`;
            if (msg.output) {
              html += formatExpandableOutput(msg.output, 10);
            }
            if (msg.cancelled) {
              html += '<div style="color: var(--warning)">(cancelled)</div>';
            } else if (msg.exitCode !== 0 && msg.exitCode !== null) {
              html += `<div style="color: var(--error)">(exit ${msg.exitCode})</div>`;
            }
            html += '</div>';
            return html;
          }

          // Skip toolResult - rendered inline with toolCall
          if (msg.role === 'toolResult') return '';
        }

        if (entry.type === 'model_change') {
          return `<div class="model-change" id="${entryId}">${tsHtml}Switched to model: <span class="model-name">${escapeHtml(entry.provider)}/${escapeHtml(entry.modelId)}</span></div>`;
        }

        if (entry.type === 'compaction') {
          return `<div class="compaction" id="${entryId}">
            <div class="compaction-header" onclick="this.parentElement.classList.toggle('expanded')">
              <span class="compaction-toggle">▶</span>
              <span class="compaction-title">Context compacted from ${entry.tokensBefore.toLocaleString()} tokens</span>
            </div>
            <div class="compaction-content">
              <div class="compaction-summary">${escapeHtml(entry.summary)}</div>
            </div>
          </div>`;
        }

        if (entry.type === 'branch_summary') {
          return `<div class="branch-summary" id="${entryId}">${tsHtml}
            <div class="branch-summary-header">Branch Summary</div>
            <div class="markdown-content">${renderMarkdown(entry.summary)}</div>
          </div>`;
        }

        if (entry.type === 'custom_message' && entry.display) {
          return `<div class="hook-message" id="${entryId}">${tsHtml}
            <div class="hook-type">[${escapeHtml(entry.customType)}]</div>
            <div class="markdown-content">${renderMarkdown(typeof entry.content === 'string' ? entry.content : JSON.stringify(entry.content))}</div>
          </div>`;
        }

        return '';
      }

      // Compute stats for current path
      function computeStats(path) {
        let userMessages = 0;
        let assistantMessages = 0;
        let toolCalls = 0;
        const tokens = { input: 0, output: 0, cacheRead: 0, cacheWrite: 0 };
        const cost = { input: 0, output: 0, cacheRead: 0, cacheWrite: 0 };
        const models = new Set();

        for (const entry of path) {
          if (entry.type === 'message') {
            const msg = entry.message;
            if (msg.role === 'user') userMessages++;
            if (msg.role === 'assistant') {
              assistantMessages++;
              if (msg.model) {
                models.add(msg.provider ? `${msg.provider}/${msg.model}` : msg.model);
              }
              if (msg.usage) {
                tokens.input += msg.usage.input || 0;
                tokens.output += msg.usage.output || 0;
                tokens.cacheRead += msg.usage.cacheRead || 0;
                tokens.cacheWrite += msg.usage.cacheWrite || 0;
                if (msg.usage.cost) {
                  cost.input += msg.usage.cost.input || 0;
                  cost.output += msg.usage.cost.output || 0;
                  cost.cacheRead += msg.usage.cost.cacheRead || 0;
                  cost.cacheWrite += msg.usage.cost.cacheWrite || 0;
                }
              }
              toolCalls += msg.content.filter(c => c.type === 'toolCall').length;
            }
          }
        }

        return { userMessages, assistantMessages, toolCalls, tokens, cost, models: Array.from(models) };
      }

      // Render header
      function renderHeader(path) {
        const stats = computeStats(path);
        const totalTokens = stats.tokens.input + stats.tokens.output + stats.tokens.cacheRead + stats.tokens.cacheWrite;
        const totalCost = stats.cost.input + stats.cost.output + stats.cost.cacheRead + stats.cost.cacheWrite;

        let html = `
          <div class="header">
            <h1>Session: ${escapeHtml(header?.id || 'unknown')}</h1>
            <div class="header-info">
              <div class="info-item"><span class="info-label">Date:</span><span class="info-value">${header?.timestamp ? new Date(header.timestamp).toLocaleString() : 'unknown'}</span></div>
              <div class="info-item"><span class="info-label">Models:</span><span class="info-value">${stats.models.join(', ') || 'unknown'}</span></div>
              <div class="info-item"><span class="info-label">Messages:</span><span class="info-value">${stats.userMessages} user, ${stats.assistantMessages} assistant</span></div>
              <div class="info-item"><span class="info-label">Tool Calls:</span><span class="info-value">${stats.toolCalls}</span></div>
              <div class="info-item"><span class="info-label">Tokens:</span><span class="info-value">${totalTokens.toLocaleString()}</span></div>
              <div class="info-item"><span class="info-label">Cost:</span><span class="info-value">$${totalCost.toFixed(4)}</span></div>
            </div>
          </div>`;

        // System prompt
        if (systemPrompt) {
          html += `<div class="system-prompt">
            <div class="system-prompt-header">System Prompt</div>
            <div class="system-prompt-content">${escapeHtml(systemPrompt)}</div>
          </div>`;
        }

        // Tools
        if (tools && tools.length > 0) {
          html += `<div class="tools-list">
            <div class="tools-header">Available Tools</div>
            <div class="tools-content">
              ${tools.map(t => `<div class="tool-item"><span class="tool-item-name">${escapeHtml(t.name)}</span> - <span class="tool-item-desc">${escapeHtml(t.description)}</span></div>`).join('')}
            </div>
          </div>`;
        }

        return html;
      }

      // Navigate to entry
      function navigateTo(targetId, scrollToTarget = true) {
        currentPath = getPath(targetId);
        renderTree();

        const headerContainer = document.getElementById('header-container');
        const messagesContainer = document.getElementById('messages');

        headerContainer.innerHTML = renderHeader(currentPath);
        messagesContainer.innerHTML = currentPath.map(renderEntry).join('');

        // Scroll to target element
        if (scrollToTarget) {
          const targetEl = document.getElementById(`entry-${targetId}`);
          if (targetEl) {
            targetEl.scrollIntoView({ behavior: 'smooth', block: 'center' });
            // Brief highlight
            targetEl.style.outline = '2px solid var(--accent)';
            setTimeout(() => { targetEl.style.outline = ''; }, 1500);
          }
        } else {
          document.getElementById('content').scrollTop = 0;
        }
      }

      // Initialize

      // Search input
      const searchInput = document.getElementById('tree-search');
      searchInput.addEventListener('input', (e) => {
        searchQuery = e.target.value;
        renderTree();
      });

      // Filter buttons
      document.querySelectorAll('.filter-btn').forEach(btn => {
        btn.addEventListener('click', () => {
          document.querySelectorAll('.filter-btn').forEach(b => b.classList.remove('active'));
          btn.classList.add('active');
          filterMode = btn.dataset.filter;
          renderTree();
        });
      });

      // Sidebar toggle (mobile)
      const sidebar = document.getElementById('sidebar');
      const overlay = document.getElementById('sidebar-overlay');
      
      document.getElementById('sidebar-toggle').addEventListener('click', () => {
        sidebar.classList.toggle('open');
        overlay.classList.toggle('open');
      });

      // Close sidebar when clicking overlay
      overlay.addEventListener('click', () => {
        sidebar.classList.remove('open');
        overlay.classList.remove('open');
      });

      // Keyboard shortcut: Escape to reset to leaf
      document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') {
          searchInput.value = '';
          searchQuery = '';
          navigateTo(leafId);
        }
        // Focus search on Ctrl/Cmd+F
        if ((e.ctrlKey || e.metaKey) && e.key === 'f') {
          e.preventDefault();
          searchInput.focus();
          searchInput.select();
        }
      });

      // Initial render
      navigateTo(leafId);
    })();
  </script>
</body>
</html>
